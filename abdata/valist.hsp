#ifndef ig_abdata_valist_hsp
#define ig_abdata_valist_hsp

#include "abheader.hsp"
#include "abbox.hsp"
#include "mod_shiftArray.hsp"
#include "mod_nullmod.hsp"
#include "mod_pvalptr.hsp"

#module abdata_valist_impl arrs_, aps_, len_

/**
arrs_(t):
	Œ^ t ‚Ì”z—ñ‚ğ‚Â abbox

aps_(i):
	self ‚ª‚Â i ”Ô–Ú‚Ì—v‘f‚ªAarrs_ ‚Ì‚Ç‚±‚ÉˆÊ’u‚µ‚Ä‚¢‚é‚©‚ğ•\‚·’lB
	t := ap_type(aps_(i)) ‚ÍA‚»‚Ì—v‘f‚ÌŒ^‚ğ•\‚·B
	k := ap_ix  (aps_(i)) ‚ÍA‚»‚Ì—v‘f‚Ì’l‚Ì arrs_(t) ‚É‚¨‚¯‚éˆÊ’u‚ğ•\‚·B

len_:
	self ‚ª‚Â—v‘f‚ÌŒÂ”B
//*/

#define ctype ap_type(%1) (((%1) & 0x7F000000) >> 24)
#define ctype ap_ix(%1)    ((%1) & 0x00FFFFFF)
#define ctype ap_make(%1, %2) ((((%1) & 0x7F) << 24) | ap_ix(%2))
#define vartype_max 7

#define true 1
#define false 0

#define ctype ap_type_at(%1) ap_type(aps_(%1))
#define ctype ap_ix_at(%1)   ap_ix(aps_(%1))

#modinit

	// vartype 0 is invalid
	abbox_new arrs_
	
	repeat vartype_max, 1
		abbox_new arrs_, cnt
	loop
	
	//dim aps_, 0
	//len_ = 0
	return getaptr(thismod)
	
#modfunc valistImpl_dup_aps__ array ref_aps
	dup ref_aps, aps_
	return
	
#modcfunc valistImpl_len
	return len_
	
#modcfunc valistImpl_type_at int i
	return ap_type_at(i)
	
#modcfunc valistImpl_try_get int i, var result, int removes
	if ( 0 <= i && i < len_ ) {
		abbox_unsafe_get_v arrs_(ap_type_at(i)), result, ap_ix_at(i)
		if ( removes ) {
			valistImpl_erase_range thismod, i, i + 1
		}
		return true
	} else {
		return false
	}
	
#modcfunc valistImpl_ref_impl array ref, int i
	assert 0 <= i && i < len_
	abbox_unsafe_dup_v arrs_(ap_type_at(i)), ref, ap_ix_at(i)
	return 0
	
#modfunc valistImpl_setv var value, int i

	assert 0 <= i && i < len_
	if ( vartype(value) == ap_type_at(i) ) {
		abbox_unsafe_set_v arrs_(ap_type_at(i)), ap_ix_at(i), value
		
	// Œ^‚ª•Ï‚í‚éê‡
	// Œ³‚Ì—v‘f‚ğœ‹‚µAV‚µ‚­‘}“ü‚µ‚½—v‘f‚Ö‚ÌƒŠƒ“ƒN‚Å’u‚«Š·‚¦‚éB
	} else {
		abbox_unsafe_erase_at arrs_(ap_type_at(i)), ap_ix_at(i)
		abbox_add arrs_(vartype(value)), value
		aps_(i) = ap_make(vartype(value), stat)
	}
	return
	
#modfunc valistImpl_insertv var value, int i

	if ( i < 0 ) {
		valistImpl_insertv value, (i \ len_) + len_
		return
	}
	
	// —v‘f”‚Ì©“®Šg’£
	if ( i > len_ ) {
		repeat i - len_, len_
			valistImpl_insertv thismod, stt_zero@, cnt
		loop
	}
	
	// V—v‘f‚É‘Î‰‚·‚é ap ‚ğ‘}“ü
	stdarray_insert_room aps_, i
	
	// V—v‘f‚ğ‘}“ü
	abbox_add arrs_(vartype(value)), value
	aps_(i) = ap_make(vartype(value), stat)
	
	len_ ++
	return
	
#modfunc valistImpl_erase_range int i_beg, int i_end
	if ( i_beg >= i_end ) { return }
	
	repeat i_end - i_beg, i_beg
		abbox_unsafe_erase_at arrs_(ap_type_at(cnt)), ap_ix_at(cnt)
	loop
	
	stdarray_erase_range aps_, len_, i_beg, i_end
	len_ -= i_end - i_beg
	return
	
#modfunc valistImpl_iter_swap int i0, int i1

	assert 0 <= i0 && i0 < len_
	assert 0 <= i1 && i1 < len_
	stdarray_loc_swap aps_, i0, i1
	return
	
#global

//##############################################################################
// wrapper

#define global valist_new(%1, %2 = 0, %3 = stt_zero@) \
	valist_new_replicate %1, %2, %3

#define global valist_delete(%1) \
	delmod abdataInsts(%1)

#define global ctype valist_make(%1 = 0, %2 = stt_zero@) \
	valist_make_replicate(%1, %2)

#define global ctype valist_size(%1) valistImpl_len(abdataInsts(%1))
#define global valist_length valist_size

#define global ctype valist_type_at(%1, %2) valistImpl_type_at(abdataInsts(%1), %2)

#define global ctype valist_try_get(%1, %2, %3) \
	valistImpl_try_get(abdataInsts(%1), %2, %3, 0 /* removes */)

#define global ctype valist_try_pop(%1, %2, %3) \
	valistImpl_try_get(abdataInsts(%1), %2, %3, 1 /* removes */)

#define global ctype valist_get(%1, %2)  valist_get__(%1, %2, 0 /* removes */)
#define global ctype valist_pop(%1, %2)  valist_get__(%1, %2, 1 /* removes */)
#define global ctype valist_get_front(%1)  valist_get(%1, 0)
#define global ctype valist_pop_front(%1)  valist_pop(%1, 0)
#define global ctype valist_get_back(%1)   valist_get_back__(%1, 0 /* removes */)
#define global ctype valist_pop_back(%1)   valist_get_back__(%1, 1 /* removes */)

#define global ctype valist_ref(%1, %2) %t__ref %i0 \
	_cat@__abdata(%p,@__tmp)( \
		valistImpl_ref_impl(abdataInsts(%1), _cat@__abdata(%p,@__tmp), (%2)) \
	) %o0 //

#define global valist_set(%1, %2, %3) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	valist_setv %1, _cat@__abdata(%o,@__tmp), %3

#define global valist_setv(%1, %2, %3) \
	valistImpl_setv abdataInsts(%1), %2, %3

#define global valist_insertv(%1, %2, %3) \
	valistImpl_insertv abdataInsts(%1), %2, %3

#define global valist_insert(%1, %2, %3) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	valist_insertv %1, _cat@__abdata(%o,@__tmp), %3

#define global valist_push_front(%1, %2)  valist_insert  (%1), %2, 0
#define global valist_pushv_front(%1, %2) valist_insertv (%1), %2, 0

#define global valist_push_back(%1, %2) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	valist_pushv_back %1, _cat@__abdata(%o,@__tmp)

#define global valist_erase_range(%1, %2, %3) \
	valistImpl_erase_range abdataInsts(%1), %2, %3

#define global valist_erase_front(%1, %2) \
	valist_erase_range %1, 0, 1

#define global valist_iter_swap(%1, %2, %3) \
	valistImpl_iter_swap abdataInsts(%1), %2, %3

#define global valist_reverse(%1, %2 = 0, %3 = stdarray_index_of_end) \
	valist_reverse__ %1, %2, %3

#module
#deffunc valist_new_empty var self
	
	// abdataInsts_var ‚ÌL’·
	#define __len length(abdataInsts_var)
		if ( __len > 1 ) : if ( varuse(abdataInsts_var(__len - 2)) ) {
			abdataInsts_var(__len * 2) = abNullmod
		}
	#undef __len
	
	newmod abdataInsts_var, abdata_valist_impl@
	self = stat
	return
#global

#module
#deffunc valist_new_replicate var self, int count, var value
	valist_new_empty self
	repeat count
		valist_insertv self, value, cnt
	loop
	return
	
#defcfunc valist_make_replicate int count, var value,  \
	local self
	
	valist_new_replicate self, count, value
	return self
#global

#module
#defcfunc valist_get__ int self, int i, int removes,  \
	local result
	
	if ( valistImpl_try_get(abdataInsts(self), i, result, removes) ) {
		return result
	}
	assert : end 1
#global

#module
#defcfunc valist_get_back__ int self, int removes,  \
	local result
	
	if ( valistImpl_try_get(abdataInsts(self), valist_size(self) - 1, result, removes) ) {
		return result
	}
	assert : end 1
#global

#module
#deffunc valist_pushv_back int self, var value
	valist_insertv self, value, valist_size(self)
	return
#global

#module
#deffunc valist_erase_at int self, int i
	valist_erase_range self, i, i + 1
	return
#global

#module
#deffunc valist_erase_back int self
	valist_erase_range self, valist_size(self) - 1, valist_size(self)
	return
#global

#module
#deffunc valist_resize int self, int new_len, var value,  \
	local len
	
	assert new_len >= 0
	len = valist_size(self)
	if ( len <= new_len ) {
		repeat new_len - len
			valist_pushv_back self, value
		loop
		
	} else {
		valist_erase_range self, new_len, len
	}
	return len
#global

#module
#deffunc valist_reverse__ int self, int i_beg, int i_end,  \
	local aps
	
	if ( i_end == stdarray_index_of_end ) {
		valist_reverse__ self, i_beg, valist_size(self)
		return
	}
	assert 0 <= i_beg && i_beg <= i_end && i_end <= valist_size(self)
	valistImpl_dup_aps__ abdataInsts(self), aps
	stdarray_reverse aps, i_beg, i_end
	return
#global

#endif
