#ifndef ig_abdata_valist_hsp
#define ig_abdata_valist_hsp

#include "abheader.hsp"
#include "abbox.hsp"
#include "mod_shiftArray.hsp"

#module abdata_valist_impl arrs_, aps_, len_

/**
arrs_(t):
	Œ^ t ‚Ì”z—ñ‚ğ‚Â abbox

aps_(i):
	self ‚ª‚Â i ”Ô–Ú‚Ì—v‘f‚ªAarrs_ ‚Ì‚Ç‚±‚ÉˆÊ’u‚µ‚Ä‚¢‚é‚©‚ğ•\‚·’lB
	t := ap_type(aps_(i)) ‚ÍA‚»‚Ì—v‘f‚ÌŒ^‚ğ•\‚·B
	k := ap_ix  (aps_(i)) ‚ÍA‚»‚Ì—v‘f‚Ì’l‚Ì arrs_(t) ‚É‚¨‚¯‚éˆÊ’u‚ğ•\‚·B

len_:
	self ‚ª‚Â—v‘f‚ÌŒÂ”B
//*/

#define ctype ap_type(%1) (((%1) & 0x7F000000) >> 24)
#define ctype ap_ix(%1)    ((%1) & 0x00FFFFFF)
#define ctype ap_make(%1, %2) ((((%1) & 0x7F) << 24) | ap_ix(%2))
#define vartype_max 7

#define true 1
#define false 0

#modinit

	// vartype 0 is invalid
	abbox_new arrs_
	
	repeat vartype_max, 1
		abbox_new arrs_, cnt
	loop
	
	//dim aps_, 0
	//len_ = 0
	return
	
#modcfunc valistImpl_len
	return len_
	
#modfunc valistImpl_insertv var value, int i

	if ( i < 0 ) {
		valistImpl_insertv value, (i \ len_) + len_
		return
	}
	
	// —v‘f”‚Ì©“®Šg’£
	if ( i > len_ ) {
		repeat i - len_, len_
			valistImpl_insertv thismod, stt_zero@, cnt
		loop
	}
	
	// V—v‘f‚É‘Î‰‚·‚é ap ‚ğ‘}“ü
	stdarray_insert_room aps_, i
	
	// V—v‘f‚ğ‘}“ü
	abbox_add arrs_(vartype(value)), value
	aps_(i) = ap_make(vartype(value), stat)
	
	len_ ++
	return
	
#global

//##############################################################################
// wrapper

#define global valist_new(%1, %2 = 0, %3 = stt_zero@) \
	valist_new__ %1, %2, %3 //unimplemented

#define global valist_delete(%1) \
	delmod abdataInsts(%1)

#define global ctype valist_size(%1) valistImpl_len(abdataInsts(%1))
#define global valist_length valist_size

#define global valist_insertv(%1, %2, %3 = 0) \
	valistImpl_insertv abdataInsts(%1), %2, %3

#define global valist_insert(%1, %2, %3 = 0) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	valist_insertv %1, _cat@__abdata(%o,@__tmp), %3

#endif
